AWSTemplateFormatVersion: "2010-09-09"
Description: >
  yStocker - single EC2 instance with a public IPv4 address.
  Runs the Flask app behind Gunicorn, managed by systemd.
  The on-disk cache (cache/) is stored on the instance volume and
  survives app restarts; it is lost only if the instance is terminated.

# -----------------------------------------------------------------------------
# Parameters
# -----------------------------------------------------------------------------
Parameters:

  InstanceType:
    Type: String
    Default: t3.small
    AllowedValues: [t3.micro, t3.small, t3.medium, t3.large]
    Description: EC2 instance type (t3.micro is free-tier eligible)

  KeyName:
    Type: AWS::EC2::KeyPair::KeyName
    Description: Name of an existing EC2 key pair for SSH access

  AllowedSSHCidr:
    Type: String
    Default: "0.0.0.0/0"
    Description: >
      CIDR range allowed to SSH into the instance.
      Restrict to your IP for better security, e.g. 203.0.113.10/32

  AppPort:
    Type: Number
    Default: 8000
    Description: Port Gunicorn listens on (also opened in the security group)

  DomainName:
    Type: String
    Default: "stock.li-family.us"
    Description: Domain name for the app (used for nginx server_name and Let's Encrypt SSL)

  CertEmail:
    Type: String
    Default: ""
    Description: Email address for Let's Encrypt certificate notifications (recommended)

  GitRepo:
    Type: String
    Default: "https://github.com/15th-Ave-NE/ystocker.git"
    Description: >
      HTTPS URL of the git repo to clone on first boot.

  LatestAL2023Ami:
    Type: AWS::SSM::Parameter::Value<AWS::EC2::Image::Id>
    Default: /aws/service/ami-amazon-linux-latest/al2023-ami-kernel-default-x86_64
    Description: Latest Amazon Linux 2023 x86_64 AMI (auto-resolved per region)

# -----------------------------------------------------------------------------
# Resources
# -----------------------------------------------------------------------------
Resources:

  # -- VPC & networking --------------------------------------------------------

  VPC:
    Type: AWS::EC2::VPC
    Properties:
      CidrBlock: 10.0.0.0/16
      EnableDnsSupport: true
      EnableDnsHostnames: true
      Tags:
        - Key: Name
          Value: !Sub "${AWS::StackName}-vpc"

  InternetGateway:
    Type: AWS::EC2::InternetGateway
    Properties:
      Tags:
        - Key: Name
          Value: !Sub "${AWS::StackName}-igw"

  VPCGatewayAttachment:
    Type: AWS::EC2::VPCGatewayAttachment
    Properties:
      VpcId: !Ref VPC
      InternetGatewayId: !Ref InternetGateway

  PublicSubnet:
    Type: AWS::EC2::Subnet
    Properties:
      VpcId: !Ref VPC
      CidrBlock: 10.0.1.0/24
      MapPublicIpOnLaunch: true          # <-- assigns a public IPv4 on launch
      AvailabilityZone: !Select [0, !GetAZs ""]
      Tags:
        - Key: Name
          Value: !Sub "${AWS::StackName}-public-subnet"

  PublicRouteTable:
    Type: AWS::EC2::RouteTable
    Properties:
      VpcId: !Ref VPC
      Tags:
        - Key: Name
          Value: !Sub "${AWS::StackName}-rtb"

  DefaultRoute:
    Type: AWS::EC2::Route
    DependsOn: VPCGatewayAttachment
    Properties:
      RouteTableId: !Ref PublicRouteTable
      DestinationCidrBlock: 0.0.0.0/0
      GatewayId: !Ref InternetGateway

  SubnetRouteTableAssociation:
    Type: AWS::EC2::SubnetRouteTableAssociation
    Properties:
      SubnetId: !Ref PublicSubnet
      RouteTableId: !Ref PublicRouteTable

  # -- Security group ----------------------------------------------------------

  InstanceSecurityGroup:
    Type: AWS::EC2::SecurityGroup
    Properties:
      GroupDescription: yStocker - allow HTTP app port + SSH
      VpcId: !Ref VPC
      SecurityGroupIngress:
        - IpProtocol: tcp
          FromPort: !Ref AppPort
          ToPort: !Ref AppPort
          CidrIp: 0.0.0.0/0
          Description: Flask/Gunicorn app
        - IpProtocol: tcp
          FromPort: 80
          ToPort: 80
          CidrIp: 0.0.0.0/0
          Description: HTTP (nginx reverse proxy)
        - IpProtocol: tcp
          FromPort: 443
          ToPort: 443
          CidrIp: 0.0.0.0/0
          Description: HTTPS (nginx + LetsEncrypt)
        - IpProtocol: tcp
          FromPort: 22
          ToPort: 22
          CidrIp: !Ref AllowedSSHCidr
          Description: SSH
      SecurityGroupEgress:
        - IpProtocol: "-1"
          CidrIp: 0.0.0.0/0
      Tags:
        - Key: Name
          Value: !Sub "${AWS::StackName}-sg"

  # -- IAM role (SSM Session Manager - optional SSH alternative) ---------------

  InstanceRole:
    Type: AWS::IAM::Role
    Properties:
      RoleName: !Sub "${AWS::StackName}-ec2-role"
      AssumeRolePolicyDocument:
        Version: "2012-10-17"
        Statement:
          - Effect: Allow
            Principal:
              Service: ec2.amazonaws.com
            Action: sts:AssumeRole
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/AmazonSSMManagedInstanceCore  # SSM Session Manager
      Tags:
        - Key: Name
          Value: !Sub "${AWS::StackName}-ec2-role"

  InstanceProfile:
    Type: AWS::IAM::InstanceProfile
    Properties:
      Roles:
        - !Ref InstanceRole

  # -- EC2 instance ------------------------------------------------------------

  Instance:
    Type: AWS::EC2::Instance
    DependsOn: VPCGatewayAttachment
    Properties:
      InstanceType: !Ref InstanceType
      KeyName: !Ref KeyName
      ImageId: !Ref LatestAL2023Ami
      SubnetId: !Ref PublicSubnet
      IamInstanceProfile: !Ref InstanceProfile
      SecurityGroupIds:
        - !Ref InstanceSecurityGroup
      BlockDeviceMappings:
        - DeviceName: /dev/xvda
          Ebs:
            VolumeSize: 20       # GB - enough for app + pip packages + cache
            VolumeType: gp3
            DeleteOnTermination: true
      Tags:
        - Key: Name
          Value: !Sub "${AWS::StackName}-instance"

      UserData:
        Fn::Base64:
          Fn::Sub: |
            #!/bin/bash
            set -euxo pipefail
            exec > >(tee /var/log/ystocker-init.log | logger -t ystocker-init) 2>&1

            # -- System packages
            dnf update -y
            dnf install -y python3.11 python3.11-pip python3.11-devel gcc git nginx

            # -- App directory
            APP_DIR=/opt/ystocker
            APP_USER=ystocker

            useradd --system --shell /sbin/nologin --home-dir "$APP_DIR" "$APP_USER" || true
            mkdir -p "$APP_DIR"

            # -- Clone or scaffold app
            if [ -n "${GitRepo}" ]; then
              git clone "${GitRepo}" /tmp/ystocker-repo
              cp -r /tmp/ystocker-repo/. "$APP_DIR/"
              rm -rf /tmp/ystocker-repo
            else
              echo "GitRepo not set - deploy code manually to $APP_DIR"
              mkdir -p "$APP_DIR/ystocker" "$APP_DIR/cache"
              echo "from flask import Flask; app = Flask(__name__)" > "$APP_DIR/ystocker/__init__.py"
            fi

            # -- Python virtual environment
            python3.11 -m venv "$APP_DIR/venv"
            source "$APP_DIR/venv/bin/activate"
            pip install --upgrade pip
            pip install gunicorn

            if [ -f "$APP_DIR/requirements.txt" ]; then
              pip install -r "$APP_DIR/requirements.txt"
            fi

            # -- Cache directory (survives app restarts)
            mkdir -p "$APP_DIR/cache"
            chown -R "$APP_USER:$APP_USER" "$APP_DIR"

            # -- Log files (must be owned by app user before gunicorn starts)
            touch /var/log/ystocker-access.log /var/log/ystocker-error.log
            chown "$APP_USER:$APP_USER" /var/log/ystocker-access.log /var/log/ystocker-error.log

            # -- git safe.directory (needed when root pulls a repo owned by ystocker)
            git config --global --add safe.directory /opt/ystocker

            # -- Auto-update service: git pull + pip sync on every boot
            {
              echo '[Unit]'
              echo 'Description=yStocker git pull on boot'
              echo 'After=network-online.target'
              echo 'Wants=network-online.target'
              echo 'Before=ystocker.service'
              echo ''
              echo '[Service]'
              echo 'Type=oneshot'
              echo 'User=root'
              echo 'WorkingDirectory=/opt/ystocker'
              echo 'ExecStart=/bin/bash -c "git config --global --add safe.directory /opt/ystocker; git -C /opt/ystocker pull origin main && /opt/ystocker/venv/bin/pip install -q -r /opt/ystocker/requirements.txt && chown -R ystocker:ystocker /opt/ystocker && chown ystocker:ystocker /var/log/ystocker-access.log /var/log/ystocker-error.log"'
              echo 'RemainAfterExit=yes'
              echo ''
              echo '[Install]'
              echo 'WantedBy=multi-user.target'
            } > /etc/systemd/system/ystocker-update.service

            # -- Gunicorn systemd service
            {
              echo '[Unit]'
              echo 'Description=yStocker Flask app (Gunicorn)'
              echo 'After=network.target ystocker-update.service'
              echo 'Wants=ystocker-update.service'
              echo ''
              echo '[Service]'
              echo 'User=ystocker'
              echo 'Group=ystocker'
              echo 'WorkingDirectory=/opt/ystocker'
              echo 'Environment="PATH=/opt/ystocker/venv/bin"'
              echo "ExecStart=/opt/ystocker/venv/bin/gunicorn \\"
              echo '          --workers 2 \'
              echo "          --bind 127.0.0.1:${AppPort} \\"
              echo '          --timeout 120 \'
              echo '          --access-logfile /var/log/ystocker-access.log \'
              echo '          --error-logfile  /var/log/ystocker-error.log \'
              echo '          "ystocker:create_app()"'
              echo 'Restart=always'
              echo 'RestartSec=5'
              echo ''
              echo '[Install]'
              echo 'WantedBy=multi-user.target'
            } > /etc/systemd/system/ystocker.service

            systemctl daemon-reload
            systemctl enable ystocker-update
            systemctl enable ystocker
            systemctl start ystocker-update
            systemctl start ystocker

            # -- nginx reverse proxy (port 80 -> gunicorn)
            {
              echo 'server {'
              echo '    listen 80;'
              echo "    server_name ${DomainName};"
              echo ''
              echo '    location / {'
              echo "        proxy_pass         http://127.0.0.1:${AppPort};"
              echo '        proxy_set_header   Host              $host;'
              echo '        proxy_set_header   X-Real-IP         $remote_addr;'
              echo '        proxy_set_header   X-Forwarded-For   $proxy_add_x_forwarded_for;'
              echo '        proxy_read_timeout 120s;'
              echo '    }'
              echo ''
              echo '    location /static/ {'
              echo '        alias /opt/ystocker/ystocker/static/;'
              echo '        expires 7d;'
              echo '        add_header Cache-Control "public";'
              echo '    }'
              echo '}'
            } > /etc/nginx/conf.d/ystocker.conf

            # Remove default nginx config
            rm -f /etc/nginx/conf.d/default.conf /etc/nginx/sites-enabled/default 2>/dev/null || true

            # Start nginx after ystocker is up to avoid 502 on first request
            systemctl enable nginx
            systemctl start ystocker
            systemctl start nginx

            # -- Let's Encrypt SSL certificate
            # Wait for DNS to resolve to this instance's public IP before running certbot.
            # The Elastic IP is assigned after the instance starts, and DNS may take
            # a few minutes to propagate — retry for up to 10 minutes.
            dnf install -y python3-certbot-nginx || dnf install -y certbot python3-certbot-nginx || true

            if [ -n "${DomainName}" ]; then
              MY_IP=$(curl -s http://169.254.169.254/latest/meta-data/public-ipv4)
              echo "Waiting for DNS: ${DomainName} -> $MY_IP"
              for i in $(seq 1 20); do
                RESOLVED=$(dig +short ${DomainName} | tail -1)
                if [ "$RESOLVED" = "$MY_IP" ]; then
                  echo "DNS resolved correctly after $i attempts."
                  break
                fi
                echo "  attempt $i: resolved to '$RESOLVED', expected '$MY_IP' — waiting 30s..."
                sleep 30
              done

              EMAIL_FLAG=""
              if [ -n "${CertEmail}" ]; then
                EMAIL_FLAG="--email ${CertEmail}"
              else
                EMAIL_FLAG="--register-unsafely-without-email"
              fi
              certbot --nginx \
                      --non-interactive \
                      --agree-tos \
                      $EMAIL_FLAG \
                      -d ${DomainName} \
                      --redirect || echo "Certbot failed - check /var/log/letsencrypt/letsencrypt.log"
            fi

            echo "yStocker bootstrap complete."

  # -- Elastic IP - persistent public IPv4 ------------------------------------

  ElasticIP:
    Type: AWS::EC2::EIP
    DependsOn: VPCGatewayAttachment
    Properties:
      Domain: vpc
      InstanceId: !Ref Instance
      Tags:
        - Key: Name
          Value: !Sub "${AWS::StackName}-eip"

# -----------------------------------------------------------------------------
# Outputs
# -----------------------------------------------------------------------------
Outputs:

  PublicIP:
    Description: Persistent public IPv4 address (Elastic IP)
    Value: !Ref ElasticIP
    Export:
      Name: !Sub "${AWS::StackName}-PublicIP"

  AppURL:
    Description: yStocker app URL
    Value: !Sub "https://${DomainName}/"

  AppURLFallback:
    Description: Direct IP URL (before DNS is configured)
    Value: !Sub "http://${ElasticIP}/"

  AppDirectPort:
    Description: Direct Gunicorn URL (bypass nginx)
    Value: !Sub "http://${ElasticIP}:${AppPort}/"

  SSHCommand:
    Description: SSH into the instance
    Value: !Sub "ssh -i ~/.ssh/${KeyName}.pem ec2-user@${ElasticIP}"

  DeployCommand:
    Description: Upload your code after stack creation
    Value: !Sub "scp -r ./ystocker ec2-user@${ElasticIP}:/tmp/ && ssh ec2-user@${ElasticIP} 'sudo cp -r /tmp/ystocker/* /opt/ystocker/ && sudo chown -R ystocker:ystocker /opt/ystocker && sudo systemctl restart ystocker'"

  LogsCommand:
    Description: Tail app logs
    Value: !Sub "ssh -i ~/.ssh/${KeyName}.pem ec2-user@${ElasticIP} 'sudo journalctl -u ystocker -f'"
